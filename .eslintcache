[{"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\index.js":"1","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\App.js":"2","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\reportWebVitals.js":"3","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\PathVisualizer\\PathVisualizer.js":"4","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\Node\\Node.js":"5","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\dijkstra.js":"6","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\index.js":"7","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\dfs.js":"8","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\bfs.js":"9","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\astar.js":"10","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\index.js":"11","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\maze-algorithms\\recursiveDivision.js":"12","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\maze-algorithms\\randomMaze.js":"13","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\maze-algorithms\\index.js":"14","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\algorithms.visualizer.js":"15","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\walls.visualizer.js":"16","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\Footer\\Footer.js":"17","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\DarkModeToggle\\DarkModeToggle.js":"18","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\ProgressBar\\ProgressBar.js":"19","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\AppNavbar\\AppNavbar.js":"20","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\ErrorModal\\ErrorModal.js":"21","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\ToolTip\\ToolTip.js":"22"},{"size":500,"mtime":499162500000,"results":"23","hashOfConfig":"24"},{"size":362,"mtime":1611318170761,"results":"25","hashOfConfig":"24"},{"size":362,"mtime":499162500000,"results":"26","hashOfConfig":"24"},{"size":18362,"mtime":1612882355121,"results":"27","hashOfConfig":"24"},{"size":702,"mtime":1612803300124,"results":"28","hashOfConfig":"24"},{"size":1458,"mtime":1612681670872,"results":"29","hashOfConfig":"24"},{"size":1692,"mtime":1609143261253,"results":"30","hashOfConfig":"24"},{"size":1640,"mtime":1610088350002,"results":"31","hashOfConfig":"24"},{"size":1638,"mtime":1610088547752,"results":"32","hashOfConfig":"24"},{"size":1453,"mtime":1610088720793,"results":"33","hashOfConfig":"24"},{"size":489,"mtime":1612965775431,"results":"34","hashOfConfig":"24"},{"size":3405,"mtime":1612966143986,"results":"35","hashOfConfig":"24"},{"size":906,"mtime":1612964802910,"results":"36","hashOfConfig":"24"},{"size":153,"mtime":1609859100166,"results":"37","hashOfConfig":"24"},{"size":1493,"mtime":1612965865402,"results":"38","hashOfConfig":"24"},{"size":670,"mtime":1612965946322,"results":"39","hashOfConfig":"24"},{"size":476,"mtime":1612803353043,"results":"40","hashOfConfig":"24"},{"size":2598,"mtime":1611593979680,"results":"41","hashOfConfig":"24"},{"size":666,"mtime":1612804490986,"results":"42","hashOfConfig":"24"},{"size":3195,"mtime":1612804893471,"results":"43","hashOfConfig":"24"},{"size":347,"mtime":1612803376415,"results":"44","hashOfConfig":"24"},{"size":914,"mtime":1612803427770,"results":"45","hashOfConfig":"24"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},"151wpan",{"filePath":"49","messages":"50","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"48"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"48"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"63","messages":"64","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"71","messages":"72","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"73","messages":"74","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"75","messages":"76","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"81","messages":"82","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83","usedDeprecatedRules":"48"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"90","usedDeprecatedRules":"48"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\index.js",[],["95","96"],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\App.js",["97"],"import React, { Component } from 'react';\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport PathVisualizer from './components/PathVisualizer/PathVisualizer';\nimport { Container } from \"reactstrap\";\n\nclass App extends Component {\n  state = {}\n\n  render() { \n    return ( \n      <div>\n        <PathVisualizer />\n      </div>\n     );\n  }\n}\n \nexport default App;","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\reportWebVitals.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\PathVisualizer\\PathVisualizer.js",["98"],"import React, { Component } from 'react';\r\nimport \"./PathVisualizer.scss\";\r\nimport Node from \"../Node/Node\";\r\nimport { dijkstra, getNodesInShortestPathOrder, dfs, bfs, astar } from \"../../algorithms\";\r\nimport { animatePath, animateWalls, setVisualizationState } from \"../../visualizers\";\r\nimport { recursiveDivisionMaze, randomMaze } from \"../../maze-algorithms\";\r\nimport AppNavbar from \"../AppNavbar/AppNavbar\";\r\nimport ErrorModal from '../../components/ErrorModal/ErrorModal';\r\nimport Footer from \"../Footer/Footer\";\r\nimport TooltipExampleMulti from '../../components/ToolTip/ToolTip';\r\n\r\n// constants - initial coordinates for start and finish nodes \r\nconst START_NODE_ROW = 10;\r\nconst START_NODE_COL = 15;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 35;\r\n\r\nclass PathVisualizer extends Component {\r\n    state = {\r\n        grid: [],\r\n        mouseIsPressed: false,\r\n        isPathNotFound: false,\r\n        visitedNodes: 0,\r\n        shortestNodes: 0,\r\n        tooltipOpen: false,\r\n        isVisualizing: false,\r\n        mainIsPressed: \"\",\r\n        startNode_Pos: [START_NODE_ROW, START_NODE_COL],\r\n        finishNode_Pos: [FINISH_NODE_ROW, FINISH_NODE_COL],\r\n    }\r\n\r\n    // creates the grid when the component is mounted\r\n    componentDidMount() {\r\n        const { startNode_Pos, finishNode_Pos } = this.state;\r\n        let grid = getInitialGrid(startNode_Pos,finishNode_Pos);\r\n        this.setState({ grid });   \r\n    }\r\n\r\n    // tool tip toggle\r\n    toggle = () => {\r\n        this.setState({ tooltipOpen: !this.state.tooltipOpen });\r\n    }\r\n\r\n/*-------------------------------------------------------------mouse events--------------------------------------------------------------- */\r\n    // handling mouse events to set up walls\r\n\r\n    handleMouseDown(row, col) {\r\n        const { grid, mainIsPressed } = this.state;\r\n        const node = grid[row][col];\r\n        if (node.isStart === true && node.isFinish === false) {\r\n            this.setState({ mainIsPressed: \"start\" });\r\n            node.isStart = false;\r\n        }\r\n        if (node.isFinish === true && node.isStart === false) {\r\n            this.setState({ mainIsPressed: \"finish\" });\r\n            node.isFinish = false;\r\n        }\r\n        if (mainIsPressed === \"\") {\r\n            const newGrid = gridWithWallToggled(grid, row, col);\r\n            this.setState({ grid: newGrid, mouseIsPressed: true });\r\n        }\r\n    }\r\n    \r\n    handleMouseEnter(row, col) {\r\n        const { grid, mouseIsPressed, mainIsPressed } = this.state;\r\n        if (mainIsPressed === \"start\") {\r\n            const newGrid = gridDynamicNodes(grid, row, col, \"start\");\r\n            this.setState({ grid: newGrid });\r\n        }\r\n        if (mainIsPressed === \"finish\") {\r\n            const newGrid = gridDynamicNodes(grid, row, col, \"finish\");\r\n            this.setState({ grid: newGrid });\r\n        }\r\n        if (mouseIsPressed && mainIsPressed === \"\") {\r\n            const newGrid = gridWithWallToggled(grid, row, col);\r\n            this.setState({ grid: newGrid, mouseIsPressed: true });\r\n        }\r\n    }\r\n\r\n    handleMouseUp(row,col) {\r\n        const { mainIsPressed, grid } = this.state;\r\n        if (mainIsPressed === \"start\") {\r\n            this.setState({ mainIsPressed: \"\" });\r\n            const startNode_Pos = [row, col];\r\n            const newGrid = gridDynamicNodes(grid, row, col, \"start\");\r\n            this.setState({ mainIsPressed: \"\", startNode_Pos, grid: newGrid });\r\n        }\r\n        if (mainIsPressed === \"finish\") {\r\n            const finishNode_Pos = [row, col];\r\n            const newGrid = gridDynamicNodes(grid, row, col, \"finish\");\r\n            this.setState({ mainIsPressed: \"\", finishNode_Pos, grid: newGrid });\r\n        }\r\n        this.setState({ mouseIsPressed: false });\r\n    }\r\n\r\n    handleMouseLeave(row, col) {\r\n        const { grid, mainIsPressed } = this.state;\r\n        if (mainIsPressed === \"\")\r\n            return;\r\n        let newGrid = grid.slice();\r\n        const node = newGrid[row][col];\r\n        if (mainIsPressed === \"start\") {\r\n            const newNode = {\r\n                ...node,\r\n                isStart: false,\r\n                isWall: false\r\n            }\r\n            newGrid[row][col] = newNode;\r\n        }\r\n        if (mainIsPressed === \"finish\") {\r\n            const newNode = {\r\n                ...node,\r\n                isFinish: false,\r\n                isWall: false\r\n            }\r\n            newGrid[row][col] = newNode;\r\n        }\r\n        this.setState({ grid: newGrid });\r\n    }\r\n\r\n/*----------------------------------------------------------algorithm helper functions---------------------------------------------------------*/\r\n    // dijkstra\r\n    visualizeDijkstra = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\r\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\r\n        const startNode = grid[start_X][start_Y];\r\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\r\n        const finishNode = grid[finish_X][finish_Y];\r\n        try {\r\n            const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.setState({\r\n                shortestNodes: nodesInShortestPathOrder.length,\r\n                visitedNodes: visitedNodesInOrder.length\r\n            });\r\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\r\n        } catch (error) {\r\n            this.setState({ isPathNotFound: true });\r\n            setTimeout(() => {\r\n                this.setState({ isPathNotFound: false });\r\n            }, 3000);\r\n        }\r\n        this.setState({ isVisualizing: !this.state.isVisualizing });\r\n    }\r\n\r\n    // dfs\r\n    visualizeDFS = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\r\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\r\n        const startNode = grid[start_X][start_Y];\r\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\r\n        const finishNode = grid[finish_X][finish_Y];\r\n        try {\r\n            const visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.setState({\r\n                shortestNodes: nodesInShortestPathOrder.length,\r\n                visitedNodes: visitedNodesInOrder.length\r\n            });\r\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\r\n        } catch (error) {\r\n            console.log(error)\r\n            this.setState({ isPathNotFound: true });\r\n            setTimeout(() => {\r\n                this.setState({ isPathNotFound: false });\r\n            }, 3000);\r\n        }\r\n    }\r\n\r\n    // bfs\r\n    visualizeBFS = async () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        const { grid, startNode_Pos, finishNode_Pos } = this.state;\r\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\r\n        const startNode = grid[start_X][start_Y];\r\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\r\n        const finishNode = grid[finish_X][finish_Y];\r\n        try {\r\n            const visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.setState({\r\n                shortestNodes: nodesInShortestPathOrder.length,\r\n                visitedNodes: visitedNodesInOrder.length\r\n            });\r\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\r\n        } catch (error) {\r\n            this.setState({ isPathNotFound: true });\r\n            setTimeout(() => {\r\n                this.setState({ isPathNotFound: false });\r\n            }, 3000);\r\n        }\r\n    }\r\n\r\n    // astar\r\n    visualizeAstar = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        const { grid,startNode_Pos,finishNode_Pos } = this.state;\r\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\r\n        const startNode = grid[start_X][start_Y];\r\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\r\n        const finishNode = grid[finish_X][finish_Y];\r\n        try {\r\n            const visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.setState({\r\n                shortestNodes: nodesInShortestPathOrder.length,\r\n                visitedNodes: visitedNodesInOrder.length\r\n            });\r\n            animatePath(this, visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\r\n        } catch (error) {\r\n            this.setState({ isPathNotFound: true });\r\n            setTimeout(() => {\r\n                this.setState({ isPathNotFound: false });\r\n            }, 3000);\r\n        }\r\n    }\r\n\r\n/*----------------------------------------------------------clear helper functions---------------------------------------------------------*/\r\n    clearGrid = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        const { startNode_Pos, finishNode_Pos } = this.state;\r\n        const start_X = startNode_Pos[0], start_Y = startNode_Pos[1];\r\n        const finish_X = finishNode_Pos[0], finish_Y = finishNode_Pos[1];\r\n        for (let row = 0; row < this.state.grid.length; row++) {\r\n            for (let col = 0; col < this.state.grid[0].length; col++) {\r\n                if (!((row === start_X && col === start_Y) || (row === finish_X && col === finish_Y))) {\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n                }\r\n            }\r\n        }\r\n        const newGrid = getInitialGrid(startNode_Pos,finishNode_Pos);\r\n        this.setState({ grid: newGrid, visitedNodes: 0, shortestNodes: 0 });\r\n    }\r\n\r\n    clearPath = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        for (let row = 0; row < this.state.grid.length; row++) {\r\n            for (let col = 0; col < this.state.grid[0].length; col++) {\r\n                if ((document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\") || document.getElementById(`node-${row}-${col}`).className === \"node node-visited\") {\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n                }\r\n            }\r\n        }\r\n        const newGrid = getGridWithoutPath(this.state.grid);\r\n        this.setState({ grid: newGrid, visitedNodes: 0, shortestNodes: 0 });\r\n    }\r\n\r\n/*----------------------------------------------------------maze generations functions---------------------------------------------------------*/\r\n    generateRecursiveDivisionMaze = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        this.setState({ isVisualizing: true });\r\n        const { grid, startNode_Pos,finishNode_Pos } = this.state;\r\n        const startNode = grid[startNode_Pos[0]][startNode_Pos[1]];\r\n        const finishNode = grid[finishNode_Pos[0]][finishNode_Pos[1]];\r\n        const walls = recursiveDivisionMaze(grid, startNode, finishNode);\r\n        this.animateWalls(walls, grid);\r\n    }\r\n\r\n    generateRandomMaze = () => {\r\n        if (this.state.isVisualizing)\r\n            return;\r\n        this.setState({ isVisualizing: true });\r\n        const { grid,startNode_Pos,finishNode_Pos } = this.state;\r\n        const startNode = grid[startNode_Pos[0]][startNode_Pos[1]];\r\n        const finishNode = grid[finishNode_Pos[0]][finishNode_Pos[1]];\r\n        const walls = randomMaze(grid, startNode, finishNode);\r\n        this.animateWalls(walls, grid);\r\n    }\r\n\r\n    animateWalls = (walls, grid) => {\r\n        for (let i = 0; i <= walls.length; i++) {\r\n            if (i === walls.length) {\r\n                setTimeout(() => {\r\n                    const newGrid = getNewGridWithMaze(this.state.grid, walls);\r\n                    this.setState({ grid: newGrid, isVisualizing: false });\r\n                }, 10 * i);\r\n                return ;\r\n            }\r\n            setTimeout(() => {\r\n                const wall = walls[i];\r\n                const node = grid[wall[0]][wall[1]];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-animated-wall\";\r\n            }, 10 * i);\r\n        }\r\n    }\r\n\r\n    setVisualization = () => {\r\n        this.setState({\r\n            isVisualizing: !this.state.isVisualizing\r\n        });\r\n    }\r\n\r\n    handleClick = () => {\r\n        setVisualizationState(this);\r\n    }\r\n\r\n    render() {\r\n        const { grid, mouseIsPressed, visitedNodes, shortestNodes } = this.state;\r\n\r\n        return (\r\n            <>\r\n                <TooltipExampleMulti />\r\n                {this.state.isPathNotFound ? <ErrorModal /> : null }\r\n                <AppNavbar\r\n                    handleDijkstra={this.visualizeDijkstra}\r\n                    handleDFS={this.visualizeDFS}\r\n                    handleBFS={this.visualizeBFS}\r\n                    handleAstar={this.visualizeAstar}\r\n                    handleClearPath={this.clearPath}\r\n                    handleClearGrid={this.clearGrid}\r\n                    handleMaze={this.generateRecursiveDivisionMaze}\r\n                    handleRandomMaze={this.generateRandomMaze}\r\n                    handleVisualization={this.setVisualization}\r\n                    visitedNodes={visitedNodes}\r\n                    shortestNodes={shortestNodes}\r\n                />\r\n           \r\n                <div className=\"grid\">\r\n                    {grid.map((row, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx}>\r\n                                {row.map((node, nodeIdx) => {\r\n                                    const { row, col, isStart, isFinish, isWall } = node;\r\n                                    return (\r\n                                        <Node\r\n                                            key={nodeIdx}\r\n                                            row={row}\r\n                                            col={col}\r\n                                            isStart={isStart}\r\n                                            isFinish={isFinish}\r\n                                            isWall={isWall}\r\n                                            mouseIsPressed={mouseIsPressed}\r\n                                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                            onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                                            onMouseUp={(row,col) => this.handleMouseUp(row,col)}\r\n                                            onMouseLeave={(row, col) => this.handleMouseLeave(row, col)}\r\n                                        />\r\n                                    )\r\n                                })}\r\n                            </div>\r\n                        )\r\n                    })}\r\n                </div>\r\n                <Footer />\r\n            </>\r\n         );\r\n    }\r\n}\r\n\r\nexport default PathVisualizer;\r\n\r\n/*------------------------------------------------------------helper functions----------------------------------------------------------------*/\r\n\r\n// creating the initial grid, calls the createNode() function\r\n// to initialise the node with initial properties\r\nconst getInitialGrid = (startNode_Pos,finishNode_Pos) => {\r\n    let grid = [];\r\n    // const startNode_Pos = [10, 15];\r\n    // const finishNode_Pos = [10, 35];\r\n    for (let row = 0; row < 20; row++) {\r\n        const currRow = [];\r\n        for (let col = 0; col < 40; col++) { //  previously I had it as 20*50\r\n            currRow.push(createNode(row, col, startNode_Pos, finishNode_Pos));\r\n        }\r\n        grid.push(currRow);\r\n    }\r\n    return grid;\r\n}\r\n\r\n// initialising the node with its initial properties\r\nconst createNode = (row, col, startNode, finishNode) => {\r\n    let start_x = startNode[0];\r\n    let start_y = startNode[1];\r\n    let finish_x = finishNode[0];\r\n    let finish_y = finishNode[1];\r\n\r\n    return {\r\n        row,\r\n        col,\r\n        isStart: row === start_x && col === start_y,\r\n        isFinish: row === finish_x && col === finish_y,\r\n        isWall: false,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        previousNode: null,\r\n        distanceToFinishNode: Math.abs(finish_x - row) + Math.abs(finish_y - col)\r\n    }\r\n}\r\n\r\n// updating the grid, when the walls are tiggered\r\nconst gridWithWallToggled = (grid, row, col) => {\r\n    let newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall\r\n    }\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}\r\n\r\n\r\nconst gridDynamicNodes = (grid, row, col, pos) => {\r\n    console.log(`start node is currently at: row: ${row} col: ${col}`);\r\n    let newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    if (pos === \"start\") {\r\n        const newNode = {\r\n            ...node,\r\n            isStart: true\r\n        }\r\n        newGrid[row][col] = newNode;\r\n    }\r\n    if (pos === \"finish\") {\r\n        const newNode = {\r\n            ...node,\r\n            isFinish: true\r\n        }\r\n        newGrid[row][col] = newNode;\r\n    }\r\n    return newGrid;\r\n}\r\n\r\n// updating the grid, resetting the features except for the walls\r\nconst getGridWithoutPath = (grid) => {\r\n    let newGrid = grid.slice();\r\n    for (let row of grid) {\r\n        for (let node of row) {\r\n            let newNode = {\r\n                ...node,\r\n                distance: Infinity,\r\n                isVisited: false,\r\n                previousNode: null,\r\n                distanceToFinishNode: Math.abs(FINISH_NODE_ROW - node.row) + Math.abs(FINISH_NODE_COL - node.col)\r\n            };\r\n            newGrid[node.row][node.col] = newNode;\r\n        }\r\n    }\r\n    return newGrid;\r\n}\r\n\r\nconst getNewGridWithMaze = (grid, walls) => {\r\n  let newGrid = grid.slice();\r\n  for (let wall of walls) {\r\n    let node = grid[wall[0]][wall[1]];\r\n    let newNode = {\r\n      ...node,\r\n      isWall: true,\r\n    };\r\n    newGrid[wall[0]][wall[1]] = newNode;\r\n  }\r\n  return newGrid;\r\n};","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\Node\\Node.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\dijkstra.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\index.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\dfs.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\bfs.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\astar.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\index.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\maze-algorithms\\recursiveDivision.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\maze-algorithms\\randomMaze.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\maze-algorithms\\index.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\algorithms.visualizer.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\walls.visualizer.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\Footer\\Footer.js",["99","100","101"],"import React from 'react';\r\nimport \"./Footer.scss\";\r\n\r\nconst Footer = () => {\r\n    return ( \r\n        <div className=\"bg-dark text-center\">\r\n            <a href=\"https://www.linkedin.com/in/sethuram-s-v-171719194/\" className=\"fa fa-linkedin\"></a>\r\n            <a href=\"https://github.com/Sethuram52001\" className=\"fa fa-github\"></a>\r\n            <a href=\"https://sethuram52001.medium.com/\" className=\"fa fa-medium\"></a>\r\n        </div>\r\n     );\r\n}\r\n \r\nexport default Footer;\r\n","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\DarkModeToggle\\DarkModeToggle.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\ProgressBar\\ProgressBar.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\AppNavbar\\AppNavbar.js",["102"],"import React, { useState } from 'react';\r\nimport \"./AppNavbar.scss\";\r\nimport {\r\n  Collapse,\r\n  Navbar,\r\n  NavbarToggler,\r\n  NavbarBrand,\r\n  Nav,\r\n  NavItem,\r\n  NavLink,\r\n  UncontrolledDropdown,\r\n  DropdownToggle,\r\n  DropdownMenu,\r\n  DropdownItem,\r\n  NavbarText,\r\n  Button,\r\n  ButtonGroup,\r\n  Progress\r\n} from 'reactstrap';\r\nimport DarkModeToggle from \"../DarkModeToggle/DarkModeToggle\";\r\nimport ProgressBar from \"../ProgressBar/ProgressBar\";\r\n\r\nconst AppNavbar = (props) => {\r\n  const [isOpen, setIsOpen] = useState(false);\r\n\r\n  const toggle = () => setIsOpen(!isOpen);\r\n\r\n  return (\r\n    <div>\r\n      <Navbar color=\"dark\" dark expand=\"md\">\r\n        <NavbarBrand href=\"/\">PathVisualizer</NavbarBrand>\r\n        <NavbarToggler onClick={toggle} />\r\n        <Collapse isOpen={isOpen} navbar>\r\n          <Nav className=\"mr-auto\" navbar>\r\n            <NavItem>\r\n              <NavLink href=\"https://github.com/Sethuram52001/Path-Finding-Visualizer\">GitHub</NavLink>\r\n            </NavItem>\r\n            <UncontrolledDropdown nav inNavbar>\r\n              <DropdownToggle nav caret>\r\n                Algorithms\r\n              </DropdownToggle>\r\n              <DropdownMenu right>\r\n                <DropdownItem>\r\n                  <Button onClick={() => { props.handleDijkstra(); props.handleVisualization() }}>Dijkstra</Button>\r\n                </DropdownItem>\r\n                <DropdownItem>\r\n                  <Button onClick={() => { props.handleDFS(); props.handleVisualization() }}>DFS</Button>              \r\n                </DropdownItem>\r\n                <DropdownItem>\r\n                  <Button onClick={() => { props.handleBFS(); props.handleVisualization() }}>BFS</Button>\r\n                </DropdownItem>\r\n                <DropdownItem>\r\n                  <Button onClick={() => { props.handleAstar(); props.handleVisualization() }}>Astar</Button>\r\n                </DropdownItem>\r\n              </DropdownMenu>\r\n            </UncontrolledDropdown>\r\n            <UncontrolledDropdown nav inNavbar>\r\n              <DropdownToggle nav caret>\r\n                Generate Maze\r\n              </DropdownToggle>\r\n              <DropdownMenu right>\r\n                <DropdownItem>\r\n                  <Button onClick={() => { props.handleMaze(); props.handleVisualization() }}>Recursive Division</Button>\r\n                </DropdownItem>\r\n                <DropdownItem>\r\n                    <Button onClick={props.handleRandomMaze}>Random Maze</Button>\r\n                </DropdownItem>\r\n              </DropdownMenu>\r\n            </UncontrolledDropdown>\r\n          </Nav>  \r\n        </Collapse>\r\n        <NavbarText>\r\n          <ProgressBar visitedNodes={props.visitedNodes} shortestNodes={props.shortestNodes} />\r\n        </NavbarText>\r\n        <NavbarText className=\"clear-functions\">\r\n          <ButtonGroup>\r\n            <Button id={\"Tooltip-\" + 0} onClick={props.handleClearPath}>Clear Path</Button>\r\n            <Button id={\"Tooltip-\" + 1} onClick={props.handleClearGrid}>Clear Grid</Button>\r\n          </ButtonGroup>          \r\n        </NavbarText>\r\n        <NavbarText>\r\n          <DarkModeToggle />\r\n        </NavbarText>\r\n      </Navbar>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default AppNavbar;","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\ErrorModal\\ErrorModal.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\ToolTip\\ToolTip.js",[],{"ruleId":"103","replacedBy":"104"},{"ruleId":"105","replacedBy":"106"},{"ruleId":"107","severity":1,"message":"108","line":4,"column":10,"nodeType":"109","messageId":"110","endLine":4,"endColumn":19},{"ruleId":"107","severity":1,"message":"111","line":5,"column":23,"nodeType":"109","messageId":"110","endLine":5,"endColumn":35},{"ruleId":"112","severity":1,"message":"113","line":7,"column":13,"nodeType":"114","endLine":7,"endColumn":102},{"ruleId":"112","severity":1,"message":"113","line":8,"column":13,"nodeType":"114","endLine":8,"endColumn":81},{"ruleId":"112","severity":1,"message":"113","line":9,"column":13,"nodeType":"114","endLine":9,"endColumn":82},{"ruleId":"107","severity":1,"message":"115","line":18,"column":3,"nodeType":"109","messageId":"110","endLine":18,"endColumn":11},"no-native-reassign",["116"],"no-negated-in-lhs",["117"],"no-unused-vars","'Container' is defined but never used.","Identifier","unusedVar","'animateWalls' is defined but never used.","jsx-a11y/anchor-has-content","Anchors must have content and the content must be accessible by a screen reader.","JSXOpeningElement","'Progress' is defined but never used.","no-global-assign","no-unsafe-negation"]