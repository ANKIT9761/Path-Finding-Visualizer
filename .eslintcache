[{"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\index.js":"1","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\App.js":"2","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\reportWebVitals.js":"3","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\PathVisualizer\\PathVisualizer.js":"4","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\Node\\Node.js":"5","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\dijkstra.js":"6","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\dijkstra.visualizers.js":"7","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\index.js":"8","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\dfs.js":"9","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\bfs.js":"10","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\astar.js":"11","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\index.js":"12","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\bfs.visualizers.js":"13","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\dfs.visualizers.js":"14","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\astar.visualizer.js":"15","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\AppNavbar.js":"16","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\ErrorModal.js":"17","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\maze-algorithms\\recursiveDivision.js":"18","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\maze-algorithms\\randomMaze.js":"19","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\maze-algorithms\\index.js":"20","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\Footer.js":"21","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\ToolTip.js":"22"},{"size":500,"mtime":499162500000,"results":"23","hashOfConfig":"24"},{"size":363,"mtime":1608202484930,"results":"25","hashOfConfig":"24"},{"size":362,"mtime":499162500000,"results":"26","hashOfConfig":"24"},{"size":14646,"mtime":1609925964246,"results":"27","hashOfConfig":"24"},{"size":738,"mtime":1609231429448,"results":"28","hashOfConfig":"24"},{"size":1440,"mtime":1609480246015,"results":"29","hashOfConfig":"24"},{"size":1095,"mtime":1609480815274,"results":"30","hashOfConfig":"24"},{"size":1692,"mtime":1609143261253,"results":"31","hashOfConfig":"24"},{"size":1349,"mtime":1609144171255,"results":"32","hashOfConfig":"24"},{"size":1378,"mtime":1609143818455,"results":"33","hashOfConfig":"24"},{"size":1315,"mtime":1609143191187,"results":"34","hashOfConfig":"24"},{"size":276,"mtime":1609045132557,"results":"35","hashOfConfig":"24"},{"size":874,"mtime":1609481341976,"results":"36","hashOfConfig":"24"},{"size":874,"mtime":1609481349103,"results":"37","hashOfConfig":"24"},{"size":876,"mtime":1609481331011,"results":"38","hashOfConfig":"24"},{"size":2769,"mtime":1609932892471,"results":"39","hashOfConfig":"24"},{"size":361,"mtime":1609660713599,"results":"40","hashOfConfig":"24"},{"size":3405,"mtime":1609830672673,"results":"41","hashOfConfig":"24"},{"size":533,"mtime":1609833198430,"results":"42","hashOfConfig":"24"},{"size":153,"mtime":1609859100166,"results":"43","hashOfConfig":"24"},{"size":645,"mtime":1609935202838,"results":"44","hashOfConfig":"24"},{"size":922,"mtime":1609933114842,"results":"45","hashOfConfig":"24"},{"filePath":"46","messages":"47","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},"151wpan",{"filePath":"49","messages":"50","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"48"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"48"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"48"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"68","messages":"69","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"70","messages":"71","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"78","messages":"79","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"80","messages":"81","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"82","messages":"83","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"84","usedDeprecatedRules":"48"},{"filePath":"85","messages":"86","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"87","messages":"88","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"48"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"93","messages":"94","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\index.js",[],["95","96"],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\App.js",["97"],"import React, { Component } from 'react';\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport PathVisualizer from './components/PathVisualizer/PathVisualizer';\nimport { Container } from \"reactstrap\";\n\nclass App extends Component {\n  state = {  }\n  render() { \n    return ( \n      <div>\n        <PathVisualizer />\n      </div>\n     );\n  }\n}\n \nexport default App;","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\reportWebVitals.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\PathVisualizer\\PathVisualizer.js",["98"],"import React, { Component } from 'react';\r\nimport \"./PathVisualizer.css\";\r\nimport Node from \"../Node/Node\";\r\nimport { dijkstra, getNodesInShortestPathOrder, dfs, bfs, astar } from \"../../algorithms\";\r\nimport { animateDijkstra, animateDFS, animateBFS, animateAStar } from \"../../visualizers\";\r\nimport { recursiveDivisionMaze, randomMaze } from \"../../maze-algorithms\";\r\nimport AppNavbar from \"../AppNavbar\";\r\nimport ErrorModal from '../ErrorModal';\r\nimport { Progress, Tooltip } from \"reactstrap\";\r\nimport Footer from \"../Footer\";\r\nimport TooltipExampleMulti from '../ToolTip';\r\n\r\n// constants\r\nconst START_NODE_ROW = 10;\r\nconst START_NODE_COL = 15;\r\nconst FINISH_NODE_ROW = 10;\r\nconst FINISH_NODE_COL = 35; \r\n\r\nclass PathVisualizer extends Component {\r\n    state = {\r\n        grid: [],\r\n        mouseIsPressed: false,\r\n        isPathNotFound: false,\r\n        totalNodes: 100,\r\n        shortestNodes: 0,\r\n        tooltipOpen: false\r\n    }\r\n    \r\n    // creates the grid when the component is mounted\r\n    componentDidMount() { \r\n        let grid = getInitialGrid();\r\n        this.setState({ grid });\r\n    }\r\n\r\n    toggle = () => {\r\n        this.setState({ tooltipOpen: !this.state.tooltipOpen });\r\n    }\r\n\r\n    // handling mouse events to set up walls\r\n    handleMouseDown(row, col) {\r\n        const newGrid = gridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n\r\n    handleMouseEnter(row, col) {\r\n        if (!this.state.mouseIsPressed)\r\n            return;\r\n        const newGrid = gridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid });\r\n    }\r\n\r\n    handleMouseUp() {\r\n        this.setState({ mouseIsPressed: false });\r\n        //console.log(\"mouse up is called\")\r\n    }\r\n\r\n/*----------------------------------------------------------algorithm helper functions---------------------------------------------------------*/\r\n    // dijkstra\r\n    visualizeDijkstra = () => {\r\n        const {grid} = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        try {\r\n            const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.setState({ \r\n                shortestNodes: nodesInShortestPathOrder.length,\r\n                totalNodes: visitedNodesInOrder.length\r\n            });\r\n            animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\r\n        } catch (error) {\r\n            console.log(\"path not found\")\r\n            this.setState({ isPathNotFound: true });\r\n            setTimeout(() => {\r\n                this.setState({ isPathNotFound: false });\r\n            }, 3000);\r\n        }\r\n    }\r\n\r\n    // dfs\r\n    visualizeDFS = () => {\r\n        const {grid} = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        try {\r\n            const visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.setState({ \r\n                shortestNodes: nodesInShortestPathOrder.length,\r\n                totalNodes: visitedNodesInOrder.length\r\n            });\r\n            animateDFS(visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);   \r\n        } catch (error) {\r\n            console.log(\"path not found\")\r\n            this.setState({ isPathNotFound: true });\r\n            setTimeout(() => {\r\n                this.setState({ isPathNotFound: false });\r\n            }, 3000);\r\n        }\r\n    }\r\n\r\n    // bfs\r\n    visualizeBFS = async() => {\r\n        const { grid } = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        try {\r\n            const visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.setState({ \r\n                shortestNodes: nodesInShortestPathOrder.length,\r\n                totalNodes: visitedNodesInOrder.length\r\n            });\r\n            animateBFS(visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);    \r\n        } catch (error) {\r\n            console.log(\"path not found\")\r\n            this.setState({ isPathNotFound: true });\r\n            setTimeout(() => {\r\n                this.setState({ isPathNotFound: false });\r\n            }, 3000);\r\n        }\r\n    }\r\n\r\n    // astar\r\n    visualizeAstar = () => {\r\n        console.log(\"a star\");\r\n        const { grid } = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        try {\r\n            const visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n            const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.setState({ \r\n                shortestNodes: nodesInShortestPathOrder.length,\r\n                totalNodes: visitedNodesInOrder.length\r\n            });\r\n            animateAStar(visitedNodesInOrder, nodesInShortestPathOrder, startNode, finishNode);\r\n        } catch (error) {\r\n            console.log(\"path not found\")\r\n            this.setState({ isPathNotFound: true });\r\n            setTimeout(() => {\r\n                this.setState({ isPathNotFound: false });\r\n            }, 3000);\r\n        }\r\n    }\r\n\r\n/*----------------------------------------------------------clear helper functions---------------------------------------------------------*/\r\n    clearGrid = () => {\r\n        for (let row = 0; row < this.state.grid.length; row++) {\r\n            for (let col = 0; col < this.state.grid[0].length; col++) {\r\n                if (!((row === START_NODE_ROW && col === START_NODE_COL) || (row === FINISH_NODE_ROW && col === FINISH_NODE_COL))) {\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n                }\r\n            }\r\n        }\r\n        const newGrid = getInitialGrid();\r\n        this.setState({ grid: newGrid });\r\n    }\r\n\r\n    clearPath = () => {\r\n        for (let row = 0; row < this.state.grid.length; row++) {\r\n            for (let col = 0; col < this.state.grid[0].length; col++) {\r\n                if ((document.getElementById(`node-${row}-${col}`).className === \"node node-shortest-path\") || document.getElementById(`node-${row}-${col}`).className === \"node node-visited\") {\r\n                    document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n                }\r\n            } \r\n        }\r\n        const newGrid = getGridWithoutPath(this.state.grid);\r\n        this.setState({ grid: newGrid });\r\n    }\r\n\r\n/*----------------------------------------------------------maze generations functions---------------------------------------------------------*/\r\n    generateRecursiveDivisionMaze = () => {\r\n        const { grid } = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const walls = recursiveDivisionMaze(grid, startNode, finishNode);\r\n        console.log(walls);\r\n        const newGrid = getNewGridWithMaze(this.state.grid, walls);\r\n        this.setState({ grid: newGrid });\r\n        for (let i = 0; i < walls.length; i++) {\r\n            let wall = walls[i];\r\n            let node = this.state.grid[wall[0]][wall[1]];\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall\";\r\n        }\r\n    }\r\n\r\n    generateRandomMaze = () => {\r\n        const { grid } = this.state;\r\n        const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n        const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n        const walls = randomMaze(grid, startNode, finishNode);\r\n        console.log(walls);\r\n        const newGrid = getNewGridWithMaze(this.state.grid, walls);\r\n        this.setState({ grid: newGrid });\r\n        for (let i = 0; i < walls.length; i++) {\r\n            let wall = walls[i];\r\n            let node = this.state.grid[wall[0]][wall[1]];\r\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-wall\"\r\n        }\r\n    }\r\n    \r\n    render() { \r\n        const { grid, mouseIsPressed } = this.state;\r\n        return ( \r\n            <>\r\n                <TooltipExampleMulti />\r\n                {this.state.isPathNotFound ? <ErrorModal /> : null }\r\n                <AppNavbar\r\n                    handleDijkstra={this.visualizeDijkstra}\r\n                    handleDFS={this.visualizeDFS}\r\n                    handleBFS={this.visualizeBFS}\r\n                    handleAstar={this.visualizeAstar}\r\n                    handleClearPath={this.clearPath}\r\n                    handleClearGrid={this.clearGrid}\r\n                    handleMaze={this.generateRecursiveDivisionMaze}\r\n                    handleRandomMaze={this.generateRandomMaze}\r\n                />\r\n                <Progress multi>\r\n                    <Progress bar animated value={(this.state.shortestNodes/this.state.totalNodes)*100}>{ ((this.state.shortestNodes/this.state.totalNodes)*100).toPrecision(4) }%</Progress>\r\n                </Progress>\r\n                <div className=\"grid\">\r\n                    {grid.map((row, rowIdx) => {\r\n                        return (\r\n                            <div key={rowIdx}>\r\n                                {row.map((node, nodeIdx) => {\r\n                                    const { row, col, isStart, isFinish, isWall } = node;\r\n                                    return (\r\n                                        <Node\r\n                                            key={nodeIdx}\r\n                                            row={row}\r\n                                            col={col}\r\n                                            isStart={isStart}\r\n                                            isFinish={isFinish}\r\n                                            isWall={isWall}\r\n                                            mouseIsPressed={mouseIsPressed}\r\n                                            onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                                            onMouseEnter={(row, col) => this.handleMouseEnter(row, col)}\r\n                                            onMouseUp={() => this.handleMouseUp()}\r\n                                        />\r\n                                    )\r\n                                })}\r\n                            </div>\r\n                        )\r\n                    })}\r\n                </div>\r\n                <Footer />\r\n            </>\r\n         );\r\n    }\r\n}\r\n \r\nexport default PathVisualizer;\r\n\r\n/*------------------------------------------------------------helper functions----------------------------------------------------------------*/\r\n\r\n// creating the initial grid, calls the createNode() function\r\n// to initialise the node with initial properties\r\nconst getInitialGrid = () => {\r\n    let grid = [];\r\n    for (let row = 0; row < 20; row++) {\r\n        const currRow = [];\r\n        for (let col = 0; col < 40; col++) { //  previously I had it as 20*50\r\n            currRow.push(createNode(row, col));\r\n        }\r\n        grid.push(currRow);\r\n    }\r\n    return grid;\r\n}\r\n\r\n// initialising the node with its initial properties\r\nconst createNode = (row, col) => {\r\n    return {\r\n        row,\r\n        col,\r\n        isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n        isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n        isWall: false,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        previousNode: null,\r\n        distanceToFinishNode: Math.abs(FINISH_NODE_ROW - row) + Math.abs(FINISH_NODE_COL - col)\r\n    }\r\n}\r\n\r\n// updating the grid, when the walls are tiggered\r\nconst gridWithWallToggled = (grid, row, col) => {\r\n    let newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n        ...node,\r\n        isWall: !node.isWall\r\n    }\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n}\r\n\r\n// updating the grid, resetting the features except for the walls\r\nconst getGridWithoutPath = (grid) => {\r\n    let newGrid = grid.slice();\r\n    for (let row of grid) {\r\n        for (let node of row) {\r\n            let newNode = {\r\n                ...node,\r\n                distance: Infinity,\r\n                isVisited: false,\r\n                previousNode: null,\r\n                distanceToFinishNode: Math.abs(FINISH_NODE_ROW - node.row) + Math.abs(FINISH_NODE_COL - node.col)\r\n            };\r\n            newGrid[node.row][node.col] = newNode;\r\n        }\r\n    }\r\n    return newGrid;\r\n}\r\n\r\nconst getNewGridWithMaze = (grid, walls) => {\r\n  let newGrid = grid.slice();\r\n  for (let wall of walls) {\r\n    let node = grid[wall[0]][wall[1]];\r\n    let newNode = {\r\n      ...node,\r\n      isWall: true,\r\n    };\r\n    newGrid[wall[0]][wall[1]] = newNode;\r\n  }\r\n  return newGrid;\r\n};\r\n/*\r\n                <Container>\r\n                    <ButtonDropdown isOpen={this.state.dropdownOpen} toggle={this.toggle}>\r\n                    <DropdownToggle caret>\r\n                        Algorithms\r\n                    </DropdownToggle>\r\n                    <DropdownMenu>\r\n                        <DropdownItem header>Pick the algorithm to visualize</DropdownItem>\r\n                        <DropdownItem>\r\n                            <Button onClick={this.visualizeDijkstra}>visualize dijkstra</Button>\r\n                        </DropdownItem>\r\n                        <DropdownItem divider />\r\n                        <DropdownItem>\r\n                            <Button onClick={this.visualizeDFS}>visualize DFS</Button>  \r\n                        </DropdownItem>\r\n                        <DropdownItem divider />\r\n                        <DropdownItem>\r\n                            <Button onClick={this.visualizeBFS}>visualize BFS</Button>    \r\n                        </DropdownItem>\r\n                        <DropdownItem divider />\r\n                        <DropdownItem>\r\n                            <Button onClick={this.visualizeAstar}>visualize A*</Button>   \r\n                        </DropdownItem>                           \r\n                    </DropdownMenu>\r\n                    </ButtonDropdown>\r\n                    <Button onClick={this.clearGrid}>Clear Grid</Button>\r\n                    <Button onClick={this.clearPath}>Clear Paths</Button>\r\n                </Container>\r\n*/","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\Node\\Node.js",["99","100","101"],"import React, { Component } from 'react';\r\nimport \"./Node.css\";\r\nimport xwing from \"../../images/x-wing.png\";\r\nimport deathstar from \"../../images/death-star.png\";\r\n\r\nconst Node = (props) => {\r\n    const { row, col, isStart, isFinish, isWall, onMouseDown, onMouseEnter, onMouseUp } = props;\r\n    const extraClassName = isStart ? 'node-start' : isFinish ? 'node-finish' : isWall ? 'node-wall' : '' ; \r\n\r\n    return ( \r\n        <div\r\n            id={`node-${row}-${col}`}\r\n            className={`node ${extraClassName}`}\r\n            onMouseDown={() => onMouseDown(row, col)}\r\n            onMouseEnter={() => onMouseEnter(row, col)}\r\n            onMouseUp={() => onMouseUp()}\r\n        >\r\n        </div>\r\n     );\r\n}\r\n \r\nexport default Node;","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\dijkstra.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\dijkstra.visualizers.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\index.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\dfs.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\bfs.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\algorithms\\astar.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\index.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\bfs.visualizers.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\dfs.visualizers.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\visualizers\\astar.visualizer.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\AppNavbar.js",["102"],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\ErrorModal.js",["103"],"import React, { useState } from 'react';\r\nimport { Modal, ModalHeader } from 'reactstrap';\r\n\r\nconst ErrorModal = (props) => {\r\n  const {\r\n    className\r\n  } = props;\r\n\r\n  return (\r\n    <div>\r\n      <Modal isOpen={true} className={className}>\r\n        <ModalHeader>Path not found</ModalHeader>\r\n      </Modal>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default ErrorModal;\r\n","C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\maze-algorithms\\recursiveDivision.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\maze-algorithms\\randomMaze.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\maze-algorithms\\index.js",[],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\Footer.js",["104"],"C:\\Users\\sethu\\OneDrive\\Desktop\\Web-Dev\\React\\path-finding-visualizer\\src\\components\\ToolTip.js",["105"],{"ruleId":"106","replacedBy":"107"},{"ruleId":"108","replacedBy":"109"},{"ruleId":"110","severity":1,"message":"111","line":4,"column":10,"nodeType":"112","messageId":"113","endLine":4,"endColumn":19},{"ruleId":"110","severity":1,"message":"114","line":9,"column":20,"nodeType":"112","messageId":"113","endLine":9,"endColumn":27},{"ruleId":"110","severity":1,"message":"115","line":1,"column":17,"nodeType":"112","messageId":"113","endLine":1,"endColumn":26},{"ruleId":"110","severity":1,"message":"116","line":3,"column":8,"nodeType":"112","messageId":"113","endLine":3,"endColumn":13},{"ruleId":"110","severity":1,"message":"117","line":4,"column":8,"nodeType":"112","messageId":"113","endLine":4,"endColumn":17},{"ruleId":"110","severity":1,"message":"118","line":17,"column":3,"nodeType":"112","messageId":"113","endLine":17,"endColumn":11},{"ruleId":"110","severity":1,"message":"119","line":1,"column":17,"nodeType":"112","messageId":"113","endLine":1,"endColumn":25},{"ruleId":"110","severity":1,"message":"115","line":1,"column":17,"nodeType":"112","messageId":"113","endLine":1,"endColumn":26},{"ruleId":"110","severity":1,"message":"120","line":3,"column":10,"nodeType":"112","messageId":"113","endLine":3,"endColumn":16},"no-native-reassign",["121"],"no-negated-in-lhs",["122"],"no-unused-vars","'Container' is defined but never used.","Identifier","unusedVar","'Tooltip' is defined but never used.","'Component' is defined but never used.","'xwing' is defined but never used.","'deathstar' is defined but never used.","'Progress' is defined but never used.","'useState' is defined but never used.","'Button' is defined but never used.","no-global-assign","no-unsafe-negation"]